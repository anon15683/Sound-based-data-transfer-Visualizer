/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DeleteLineCheckboxPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/utils/createCheckAndDeleteSvg.ts
function createCheckAndDeleteSvg(span) {
  const svg = span.createSvg("svg");
  svg.setAttribute("viewBox", "0 0 100 100");
  const path = svg.createSvg("path", "check-and-delete-path");
  path.setAttribute("d", "M15,15 L85,85 M15,85 L85,15");
}
var createCheckAndDeleteSvg_default = createCheckAndDeleteSvg;

// src/utils/regexConstants.ts
var INDEX_OF_PREFIX_REGEX = /-\s*\([xX]\)/;
var CHECK_AND_DELETE_FULL_PREFIX_REGEX = /^\s*-\s\([xX]\)\s/;
var CHECK_AND_DELETE_FULL_PREFIX_EMPTY_LINE_REGEX = /^\s*-\s\([xX]\)\s*$/;
var CHECK_AND_DELETE_FULL_PREFIX_NON_EMPTY_LINE_REGEX = /^\s*-\s\([xX]\)\s+\S/;
var CHECK_AND_DELETE_NO_HYPHEN_REGEX = /^\s*\([xX]\)\s/;
var STARTS_WITH_TABS_REGEX = /^\t*/;

// src/plugins/check-and-delete-plugin/features/checkAndDeletePostProcessor.ts
function addCheckAndDeletePostProcessor(plugin) {
  plugin.registerMarkdownPostProcessor((element, context) => {
    renderCheckAndDeleteInMarkdown(element);
  });
}
function renderCheckAndDeleteInMarkdown(element) {
  if (element.className == "el-ul") {
    iterateCheckAndDeleteChildren(element);
  }
}
function iterateCheckAndDeleteChildren(element) {
  const children = element.childNodes;
  children.forEach((child) => {
    var _a;
    if (child instanceof HTMLUListElement || // UnorderedList contains ListItems
    child instanceof HTMLLIElement || // ListItems contains Span and Text items
    child instanceof HTMLParagraphElement) {
      iterateCheckAndDeleteChildren(child);
    } else if (child instanceof HTMLSpanElement && child.className == "list-bullet" && CHECK_AND_DELETE_NO_HYPHEN_REGEX.test((_a = element.textContent) != null ? _a : "")) {
      child.className = "check-and-delete-task-button";
      child.onClickEvent(() => {
        checkAndDeleteHandler(element);
      });
      createCheckAndDeleteSvg_default(child);
    } else if (child instanceof Text) {
      child.data = child.data.replace(CHECK_AND_DELETE_NO_HYPHEN_REGEX, "");
    }
  });
}
function checkAndDeleteHandler(listItem) {
  deleteElementFromPreview(listItem);
  deleteElementFromEditor(listItem);
}
function deleteElementFromPreview(element) {
  element.remove();
}
async function deleteElementFromEditor(element) {
  const activeFile = this.app.workspace.getActiveFile();
  const elementText = getElementText(element);
  if (activeFile) {
    await this.app.vault.process(activeFile, (data) => {
      const fileLines = data.split("\n");
      const newFileLines = [];
      for (let i = 0; i < fileLines.length; i++) {
        const nextLine = fileLines[i];
        const nextLineText = nextLine.replace(CHECK_AND_DELETE_FULL_PREFIX_REGEX, "");
        if (CHECK_AND_DELETE_FULL_PREFIX_REGEX.test(nextLine) && nextLineText == elementText) {
          i = skipChildLines(fileLines, i);
        } else {
          newFileLines.push(nextLine);
        }
      }
      return newFileLines.join("\n");
    });
  }
}
function getElementText(element) {
  let elementText = "";
  const children = element.childNodes;
  for (let i = 0; i < children.length; i++) {
    const child = children.item(i);
    if (child instanceof Text) {
      const nextElementSibling = child.nextElementSibling;
      elementText += nextElementSibling instanceof HTMLParagraphElement ? nextElementSibling.innerText : child.data;
    } else if (child instanceof HTMLAnchorElement) {
      if (child.className.contains("internal-link")) {
        elementText += `[[${child.textContent}]]`;
      } else {
        let anchorText = child.outerHTML;
        anchorText = anchorText.replace(' target="_blank"', "");
        anchorText = anchorText.replace(' rel="noopener nofollow"', "");
        elementText += anchorText;
      }
    }
  }
  return elementText.trim();
}
function skipChildLines(fileLines, indexOfDeletedLine) {
  var _a, _b;
  const deletedLineIndentLevelMatch = fileLines[indexOfDeletedLine].match(STARTS_WITH_TABS_REGEX);
  const deletedLineIndentLevel = (_a = deletedLineIndentLevelMatch == null ? void 0 : deletedLineIndentLevelMatch[0].length) != null ? _a : 0;
  for (let i = indexOfDeletedLine + 1; i < fileLines.length; i++) {
    const subsequentLineIndentLevelMatch = fileLines[i].match(STARTS_WITH_TABS_REGEX);
    const subsequentLineIndentLevel = (_b = subsequentLineIndentLevelMatch == null ? void 0 : subsequentLineIndentLevelMatch[0].length) != null ? _b : 0;
    if (subsequentLineIndentLevel <= deletedLineIndentLevel) {
      return i - 1;
    }
  }
  return fileLines.length;
}
var checkAndDeletePostProcessor_default = addCheckAndDeletePostProcessor;

// src/plugins/check-and-delete-plugin/checkAndDeletePlugin.ts
var import_view5 = require("@codemirror/view");
var import_state4 = require("@codemirror/state");

// src/plugins/check-and-delete-plugin/features/decoratorBuilder.ts
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");

// src/plugins/check-and-delete-plugin/features/checkAndDeleteDecoratorWidget.ts
var import_view = require("@codemirror/view");
var CheckAndDeleteDecoratorWidget = class extends import_view.WidgetType {
  toDOM(view) {
    return this.createCheckAndDeleteButton();
  }
  createCheckAndDeleteButton() {
    const checkAndDeleteButton = document.createElement("span");
    checkAndDeleteButton.className = "check-and-delete-task-button";
    checkAndDeleteButton.onclick = () => {
      var _a, _b;
      const toBeRemovedElements = [];
      const parent = checkAndDeleteButton.parentNode;
      toBeRemovedElements.push(parent);
      const parentIndentLevel = this.extractIndentLevelFromClassname(parent.className);
      let nextSibling = parent.nextElementSibling;
      let nextSiblingIndentLevel = this.extractIndentLevelFromClassname((_a = nextSibling == null ? void 0 : nextSibling.className) != null ? _a : "");
      while (nextSibling && nextSiblingIndentLevel > parentIndentLevel) {
        toBeRemovedElements.push(nextSibling);
        nextSibling = nextSibling.nextElementSibling;
        nextSiblingIndentLevel = this.extractIndentLevelFromClassname((_b = nextSibling == null ? void 0 : nextSibling.className) != null ? _b : "");
      }
      toBeRemovedElements.forEach((element) => {
        element.remove();
      });
    };
    createCheckAndDeleteSvg_default(checkAndDeleteButton);
    return checkAndDeleteButton;
  }
  extractIndentLevelFromClassname(classname) {
    const match = classname.match(/HyperMD-list-line-(\d+)/);
    if (match) {
      return Number(match[1]);
    } else {
      return 0;
    }
  }
};
var checkAndDeleteDecoratorWidget_default = CheckAndDeleteDecoratorWidget;

// src/plugins/check-and-delete-plugin/features/decoratorBuilder.ts
function buildDecorations(editorView) {
  const builder = new import_state.RangeSetBuilder();
  const { doc: document2 } = editorView.state;
  editorView.visibleRanges.forEach((visibleRange) => {
    for (let position = visibleRange.from; position <= visibleRange.to; ) {
      const line = document2.lineAt(position);
      const lineText = line.text;
      if (CHECK_AND_DELETE_FULL_PREFIX_REGEX.test(lineText)) {
        const startIndex = lineText.indexOf("-");
        const decoration = import_view2.Decoration.replace({
          widget: new checkAndDeleteDecoratorWidget_default()
        });
        builder.add(line.from + startIndex, line.from + startIndex + 5, decoration);
      }
      position = line.to + 1;
    }
  });
  return builder.finish();
}
var decoratorBuilder_default = buildDecorations;

// src/plugins/check-and-delete-plugin/features/moveCursorToEnd.ts
function moveCursorToEnd(editorView) {
  const { state } = editorView;
  const selection = state.selection;
  const line = state.doc.lineAt(selection.main.head);
  if (CHECK_AND_DELETE_FULL_PREFIX_EMPTY_LINE_REGEX.test(line.text) && selection.main.head < line.to) {
    requestAnimationFrame(() => {
      editorView.dispatch(
        {
          // Append trailing space
          changes: { from: line.from, to: line.to, insert: line.text + " " }
        },
        {
          // Move the cursor to the line end
          selection: { anchor: line.to }
        }
      );
    });
  }
}
var moveCursorToEnd_default = moveCursorToEnd;

// src/plugins/check-and-delete-plugin/features/enterKeyInterceptor.ts
var import_view3 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
function insertCheckAndDeletePrefixToNextLine() {
  return import_view3.keymap.of([{
    key: "Enter",
    run(editorView) {
      var _a;
      const { state } = editorView;
      const selection = state.selection;
      const line = state.doc.lineAt(selection.main.head);
      if (CHECK_AND_DELETE_FULL_PREFIX_NON_EMPTY_LINE_REGEX.test(line.text)) {
        let checkAndDeletePrefix = "\n";
        checkAndDeletePrefix += line.text.substring(0, line.text.indexOf("-"));
        checkAndDeletePrefix += "- (x) ";
        editorView.dispatch(
          {
            // Insert checkAndDeletePrefix to new line
            changes: { from: selection.main.head, insert: checkAndDeletePrefix },
            // Move the cursor after the insertion
            selection: { anchor: selection.main.head + checkAndDeletePrefix.length }
          }
        );
        return true;
      } else if (CHECK_AND_DELETE_FULL_PREFIX_EMPTY_LINE_REGEX.test(line.text)) {
        const startIndexMatch = line.text.match(INDEX_OF_PREFIX_REGEX);
        if ((_a = startIndexMatch == null ? void 0 : startIndexMatch.index) != null ? _a : 0 > 0) {
          editorView.dispatch({
            changes: { from: line.from, to: line.from + 1, insert: "" }
          });
        } else {
          editorView.dispatch({
            changes: { from: line.from, to: line.to, insert: "" }
          });
        }
        return true;
      }
      return false;
    }
  }]);
}
function addEnterKeyInterceptor(plugin) {
  plugin.registerEditorExtension(
    import_state2.Prec.high(insertCheckAndDeletePrefixToNextLine())
  );
}
var enterKeyInterceptor_default = addEnterKeyInterceptor;

// src/utils/isSourceMode.ts
var import_obsidian = require("obsidian");
function isSourceMode() {
  const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (view) {
    if (view.getMode() == "preview") {
      return false;
    } else {
      const state = view.getState();
      const source = state["source"];
      return source;
    }
  }
  return false;
}
var isSourceMode_default = isSourceMode;

// src/plugins/check-and-delete-plugin/features/homeKeyInterceptor.ts
var import_view4 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");
function preventMovingCursorPastWidget(key) {
  return import_view4.keymap.of([{
    key,
    run(editorView) {
      const { state } = editorView;
      const selection = state.selection;
      const line = state.doc.lineAt(selection.main.head);
      const isShifted = key.contains("Shift");
      if (CHECK_AND_DELETE_FULL_PREFIX_NON_EMPTY_LINE_REGEX.test(line.text)) {
        const startIndexMatch = line.text.match(INDEX_OF_PREFIX_REGEX);
        const positionOfWidget = line.from + startIndexMatch.index + "- (x) ".length;
        if (selection.main.head > positionOfWidget) {
          editorView.dispatch(
            {
              selection: {
                anchor: isShifted ? selection.main.head : positionOfWidget,
                head: isShifted ? positionOfWidget : void 0
              }
            }
          );
        } else {
          editorView.dispatch(
            {
              selection: {
                anchor: isShifted ? selection.main.head : line.from,
                head: isShifted ? line.from : void 0
              }
            }
          );
        }
        return true;
      }
      return false;
    }
  }]);
}
function addHomeKeyInterceptor(plugin) {
  plugin.registerEditorExtension(
    import_state3.Prec.high(preventMovingCursorPastWidget("Shift-Home"))
  );
  plugin.registerEditorExtension(
    import_state3.Prec.high(preventMovingCursorPastWidget("Home"))
  );
}
var homeKeyInterceptor_default = addHomeKeyInterceptor;

// src/plugins/check-and-delete-plugin/checkAndDeletePlugin.ts
var CheckAndDeleteDecorator = class {
  constructor(editorView) {
    this.decorations = this.setDecorationsForMode(editorView);
  }
  update(viewUpdate) {
    this.decorations = this.setDecorationsForMode(viewUpdate.view);
    if (viewUpdate.docChanged) {
      moveCursorToEnd_default(viewUpdate.view);
    }
  }
  destroy() {
  }
  setDecorationsForMode(editorView) {
    if (isSourceMode_default()) {
      return import_state4.RangeSet.empty;
    } else {
      return decoratorBuilder_default(editorView);
    }
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var TaskButtonPlugin = import_view5.ViewPlugin.fromClass(
  CheckAndDeleteDecorator,
  pluginSpec
);
function addCheckAndDeletePlugin(plugin) {
  plugin.registerEditorExtension(TaskButtonPlugin);
  checkAndDeletePostProcessor_default(plugin);
  enterKeyInterceptor_default(plugin);
  homeKeyInterceptor_default(plugin);
}
var checkAndDeletePlugin_default = addCheckAndDeletePlugin;

// src/main.ts
var DeleteLineCheckboxPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    checkAndDeletePlugin_default(this);
  }
};


/* nosourcemap */